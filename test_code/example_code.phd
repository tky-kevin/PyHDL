from core import bit, In, Out, Module

# ==========================================
# 測試面向 1: 基礎模組定義與組合邏輯
# ==========================================
class Adder(Module):
    a = In(bit[8])
    b = In(bit[8])
    s = Out(bit[9])  # 顯式宣告輸出寬度
    
    # 測試: 組合邏輯賦值與運算子支援
    s = a + b

# ==========================================
# 測試面向 2: 頂層模組、實例化與複雜邏輯
# ==========================================
class TopSystem(Module):
    # 埠號定義
    clk   = In(bit)
    rst   = In(bit)
    sw_a  = In(bit[8])
    sw_b  = In(bit[8])
    limit = In(bit[8])
    led_q = Out(bit[9])
    match = Out(bit)

    # 測試面向 3: 子模組實例化 (Instantiation)
    # 轉譯器應自動產生 Adder u1 (...); 並處理輸出連線
    u1 = Adder()
    u1.a = sw_a
    u1.b = sw_b

    # 測試面向 4: 二維陣列 (Memory) 與邊界檢查
    # 宣告 16 列，每列 8 位元
    mem = bit[16][8]
    
    # 測試面向 5: 自動位元寬度推斷 (Implicit Declaration)
    # count 未宣告，轉譯器應推斷為 8-bit 並生成 logic [7:0] count;
    count = bit[8]

    # 測試面向 6: 同步與非同步重置邏輯 (Sequential Logic)
    if clk.posedge or rst.posedge:
        if rst:
            # 測試: 常數自動格式化 -> 應轉為 8'd0
            count = 0
            led_q = 0
        else:
            # 測試: 同步區塊內的 if-else 巢狀邏輯
            if count < limit:
                count = count + 1
            else:
                count = 0
            
            # 測試面向 7: 存取子模組輸出 (Auto-wiring)
            # 應自動轉譯為中間訊號 u1_s
            led_q = u1.s

    # 測試面向 8: 組合邏輯比較與常數格式化
    # 應轉為 assign match = (count == 8'd255);
    match = (count == 255)

    # 測試面向 9: 記憶體存取
    # 讀取 mem 第 5 列並賦值給 temp (自動推斷 temp 為 8-bit)
    temp = mem[5]

class BusJoin(Module):
    high_byte = In(bit[8])
    low_byte  = In(bit[8])
    # 串接後自動推斷為 16-bit
    full_bus  = Out(bit[16])
    
    # 使用 Python Tuple 語法進行位元串接
    full_bus = (high_byte, low_byte)

from core import bit, In, Out, Module, Enum

class FSM_Example(Module):
    clk = In(bit)
    rst = In(bit)
    start = In(bit)
    done = Out(bit)

    # 1. 定義狀態列舉
    class State(Enum):
        IDLE = 0
        RUN  = 1
        FINISH = 2

    # 2. 宣告狀態變數
    curr_state = State

    # 3. 狀態機邏輯
    if clk.posedge or rst.posedge:
        if rst:
            curr_state = State.IDLE
            done = 0
        else:
            match curr_state:
                case State.IDLE:
                    if start:
                        curr_state = State.RUN
                        done = 0
                case State.RUN:
                    curr_state = State.FINISH
                case State.FINISH:
                    done = 1
                    curr_state = State.IDLE