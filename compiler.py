"""
PyHDL Compiler
==============
Command-line interface for the PyHDL transpiler.

This module provides the entry point for converting .phd (PyHDL) files
to SystemVerilog (.sv) files. It supports both single-file and batch
compilation modes.

Usage:
    python compiler.py input.phd -o output_dir/
    python compiler.py src_dir/ -o hdl_dir/
    python compiler.py src_dir/ -o hdl_dir/ -v

Author: PyHDL Team
"""

import os
import ast
import argparse
from colorama import init, Fore, Style
from transpiler import PyHDLTranspiler

# Initialize colored terminal output
init(autoreset=True)


def collect_phd_files(input_path: str) -> list:
    """Collect all .phd files from the given path.
    
    Args:
        input_path: Path to a file or directory
        
    Returns:
        List of absolute paths to .phd files
        
    Raises:
        FileNotFoundError: If the path does not exist
        ValueError: If a single file is not a .phd file
    """
    if not os.path.exists(input_path):
        raise FileNotFoundError(f"Path not found: {input_path}")
    
    if os.path.isdir(input_path):
        phd_files = []
        for root, _, files in os.walk(input_path):
            for file in files:
                if file.endswith(".phd"):
                    phd_files.append(os.path.join(root, file))
        return phd_files
    else:
        if not input_path.endswith(".phd"):
            raise ValueError("Input file must have .phd extension")
        return [input_path]


def transpile_file(input_file: str, output_dir: str, verbose: bool = False) -> tuple:
    """Transpile a single .phd file to SystemVerilog.
    
    Args:
        input_file: Path to the .phd source file
        output_dir: Directory to write the output .sv file
        verbose: If True, print detailed error information
        
    Returns:
        Tuple of (success: bool, module_names: list, warnings: list)
    """
    output_file = os.path.join(
        output_dir, 
        os.path.basename(input_file).replace(".phd", ".sv")
    )
    
    try:
        # Read source file
        with open(input_file, "r", encoding="utf-8") as f:
            source_code = f.read()
        
        # Parse and transpile
        tree = ast.parse(source_code)
        transpiler = PyHDLTranspiler()
        transpiler.visit(tree)
        sv_result = transpiler.get_verilog()
        
        # Write output file
        with open(output_file, "w", encoding="utf-8") as f:
            f.write(f"// Generated by PyHDL Transpiler\n")
            f.write(f"// Source: {os.path.abspath(input_file)}\n\n")
            f.write(sv_result)
        
        return True, list(transpiler.modules.keys()), transpiler.warnings
        
    except Exception as e:
        if verbose:
            import traceback
            traceback.print_exc()
        return False, [], [str(e)]


def print_summary(total: int, success: int, failed: int, warnings: int, output_dir: str):
    """Print the batch compilation summary."""
    print(f"\n{Fore.CYAN}{Style.BRIGHT}{'='*50}")
    print(f"{Fore.CYAN}{Style.BRIGHT}Batch Transpilation Summary")
    print(f"{Fore.WHITE}Total Files     : {total}")
    print(f"{Fore.GREEN}Successful      : {success}")
    if failed > 0:
        print(f"{Fore.RED}Failed          : {failed}")
    if warnings > 0:
        print(f"{Fore.YELLOW}Total Warnings  : {warnings}")
    print(f"{Fore.WHITE}Output Directory: {os.path.abspath(output_dir)}")
    
    if failed == 0:
        print(f"\n{Fore.GREEN}{Style.BRIGHT}Batch process completed!{Style.RESET_ALL}\n")
    else:
        print(f"\n{Fore.YELLOW}{Style.BRIGHT}Batch process completed with errors.{Style.RESET_ALL}\n")


def run_compiler():
    """Main entry point for the PyHDL compiler."""
    
    # Parse command-line arguments
    parser = argparse.ArgumentParser(
        description="PyHDL Transpiler: Convert Python hardware descriptions to SystemVerilog",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python compiler.py example.phd              # Single file
  python compiler.py src/ -o hdl/             # Directory
  python compiler.py src/ -o hdl/ -v          # Verbose mode
        """
    )
    parser.add_argument(
        "input", 
        nargs="?", 
        default="./src",
        help="Input .phd file or directory (default: ./src)"
    )
    parser.add_argument(
        "-o", "--outdir", 
        default="./hdl",
        help="Output directory for .sv files (default: ./hdl)"
    )
    parser.add_argument(
        "-v", "--verbose", 
        action="store_true",
        help="Enable verbose output with stack traces"
    )
    
    args = parser.parse_args()
    
    # Collect input files
    try:
        phd_files = collect_phd_files(args.input)
    except FileNotFoundError as e:
        print(f"{Fore.RED}[Error] {e}")
        return
    except ValueError as e:
        print(f"{Fore.RED}[Error] {e}")
        return
    
    if not phd_files:
        print(f"{Fore.YELLOW}[Warning] No .phd files found in {args.input}")
        return
    
    # Create output directory if needed
    if not os.path.exists(args.outdir):
        os.makedirs(args.outdir)
    
    # Print header for batch mode
    is_batch = len(phd_files) > 1
    if is_batch:
        print(f"{Fore.CYAN}{Style.BRIGHT}>>> PyHDL Batch Transpiler")
        print(f"{Fore.WHITE}Source Directory: {os.path.abspath(args.input)}")
        print(f"{Fore.WHITE}Found {len(phd_files)} .phd file(s)\n")
    
    # Process each file
    success_count = 0
    fail_count = 0
    total_warnings = 0
    
    for idx, input_file in enumerate(phd_files, 1):
        file_label = os.path.basename(input_file)
        
        if is_batch:
            print(f"{Fore.CYAN}[{idx}/{len(phd_files)}] Transpiling: {file_label}", end=" ... ")
        
        success, modules, warnings = transpile_file(input_file, args.outdir, args.verbose)
        
        if success:
            success_count += 1
            total_warnings += len(warnings)
            
            if warnings:
                if is_batch:
                    print(f"{Fore.YELLOW}⚠ Warning")
                for w in warnings:
                    prefix = "    " if is_batch else "  "
                    print(f"{prefix}{Fore.YELLOW}[!] {w}")
            else:
                if is_batch:
                    print(f"{Fore.GREEN}✓ Success")
            
            # Single file mode: print additional info
            if not is_batch:
                output_file = os.path.join(
                    args.outdir, 
                    os.path.basename(input_file).replace(".phd", ".sv")
                )
                print(f"\n{Fore.WHITE}Output  : {output_file}")
                print(f"{Fore.WHITE}Modules : {', '.join(modules)}")
                if not warnings:
                    print(f"\n{Fore.GREEN}{Style.BRIGHT}Successfully transpiled!{Style.RESET_ALL}\n")
        else:
            fail_count += 1
            if is_batch:
                print(f"{Fore.RED}✗ Failed")
                for w in warnings:
                    print(f"    {Fore.RED}Reason: {w}")
            else:
                print(f"\n{Fore.RED}{Style.BRIGHT}[Transpilation Failed]")
                for w in warnings:
                    print(f"{Fore.RED}Reason: {w}")
    
    # Print summary for batch mode
    if is_batch:
        print_summary(len(phd_files), success_count, fail_count, total_warnings, args.outdir)


if __name__ == "__main__":
    run_compiler()