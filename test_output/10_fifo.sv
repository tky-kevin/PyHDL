// Generated by PyHDL Transpiler
// Source: C:\Users\tkyke\OneDrive\Desktop\pyhdl\test_code\10_fifo.phd

module SyncFIFO (
    input logic clk,
    input logic rst_n,
    input logic wr_en,
    input logic [7:0] din,
    output logic full,
    input logic rd_en,
    output logic [7:0] dout,
    output logic empty,
    output logic [4:0] count
);
    logic [7:0] mem [0:15];
    logic [3:0] wr_ptr;
    logic [3:0] rd_ptr;
    always_comb begin
        full = 1'd0;
        empty = 1'd0;
        if ((count == 0)) begin
            empty = 1'd1;
        end
        if ((count == 16)) begin
            full = 1'd1;
        end
    end
    always_ff @(posedge clk or negedge rst_n) begin
        if ((!rst_n)) begin
            wr_ptr <= 4'd0;
            rd_ptr <= 4'd0;
            count <= 5'd0;
            dout <= 8'd0;
            mem[0] <= 1'd0;
            mem[1] <= 1'd0;
            mem[2] <= 1'd0;
            mem[3] <= 1'd0;
            mem[4] <= 1'd0;
            mem[5] <= 1'd0;
            mem[6] <= 1'd0;
            mem[7] <= 1'd0;
            mem[8] <= 1'd0;
            mem[9] <= 1'd0;
            mem[10] <= 1'd0;
            mem[11] <= 1'd0;
            mem[12] <= 1'd0;
            mem[13] <= 1'd0;
            mem[14] <= 1'd0;
            mem[15] <= 1'd0;
        end else begin
            if ((wr_en && (!full))) begin
                mem[wr_ptr] <= din;
                wr_ptr <= (wr_ptr + 1);
                if ((!rd_en)) begin
                    count <= (count + 1);
                end
            end
            if ((rd_en && (!empty))) begin
                dout <= mem[rd_ptr];
                rd_ptr <= (rd_ptr + 1);
                if ((!wr_en)) begin
                    count <= (count - 1);
                end
            end
        end
    end
endmodule

module FIFOTestTop (
    input logic sys_clk,
    input logic sys_rst_n,
    input logic [7:0] data_in,
    input logic data_valid,
    input logic data_read,
    output logic [7:0] data_out,
    output logic fifo_full,
    output logic fifo_empty,
    output logic [4:0] fifo_count
);
    logic u_fifo_full;
    logic [7:0] u_fifo_dout;
    logic u_fifo_empty;
    logic [4:0] u_fifo_count;
    SyncFIFO_DATA_W8_DEPTH16_PTR_W4 u_fifo (.clk(sys_clk), .rst_n(sys_rst_n), .wr_en(data_valid), .din(data_in), .full(u_fifo_full), .rd_en(data_read), .dout(u_fifo_dout), .empty(u_fifo_empty), .count(u_fifo_count));
    always_comb begin
        data_out = u_fifo_dout;
        fifo_full = u_fifo_full;
        fifo_empty = u_fifo_empty;
        fifo_count = u_fifo_count;
    end
endmodule

module SyncFIFO_DATA_W8_DEPTH16_PTR_W4 (
    input logic clk,
    input logic rst_n,
    input logic wr_en,
    input logic [7:0] din,
    output logic full,
    input logic rd_en,
    output logic [7:0] dout,
    output logic empty,
    output logic [4:0] count
);
    logic [7:0] mem [0:15];
    logic [3:0] wr_ptr;
    logic [3:0] rd_ptr;
    always_comb begin
        full = 1'd0;
        empty = 1'd0;
        if ((count == 0)) begin
            empty = 1'd1;
        end
        if ((count == 16)) begin
            full = 1'd1;
        end
    end
    always_ff @(posedge clk or negedge rst_n) begin
        if ((!rst_n)) begin
            wr_ptr <= 4'd0;
            rd_ptr <= 4'd0;
            count <= 5'd0;
            dout <= 8'd0;
            mem[0] <= 1'd0;
            mem[1] <= 1'd0;
            mem[2] <= 1'd0;
            mem[3] <= 1'd0;
            mem[4] <= 1'd0;
            mem[5] <= 1'd0;
            mem[6] <= 1'd0;
            mem[7] <= 1'd0;
            mem[8] <= 1'd0;
            mem[9] <= 1'd0;
            mem[10] <= 1'd0;
            mem[11] <= 1'd0;
            mem[12] <= 1'd0;
            mem[13] <= 1'd0;
            mem[14] <= 1'd0;
            mem[15] <= 1'd0;
        end else begin
            if ((wr_en && (!full))) begin
                mem[wr_ptr] <= din;
                wr_ptr <= (wr_ptr + 1);
                if ((!rd_en)) begin
                    count <= (count + 1);
                end
            end
            if ((rd_en && (!empty))) begin
                dout <= mem[rd_ptr];
                rd_ptr <= (rd_ptr + 1);
                if ((!wr_en)) begin
                    count <= (count - 1);
                end
            end
        end
    end
endmodule