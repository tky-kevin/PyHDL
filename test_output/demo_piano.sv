// Generated by PyHDL Transpiler
// Source: C:\Users\tkyke\OneDrive\Desktop\pyhdl\test_code\demo_piano.phd

module Piano (
    input logic clk,
    input logic [7:0] keys,
    input logic [1:0] song_sel,
    input logic rec_btn,
    input logic play_btn,
    output logic buzzer
);
    typedef enum logic [1:0] {IDLE=2'd0, REC=2'd1, PLAY=2'd2} State_t;
    State_t state;
    logic [7:0] active_keys;
    logic [19:0] counter_limit;
    logic [19:0] counter;
    logic buzzer_reg;
    logic [7:0] ram [0:11999];
    logic [13:0] ram_addr;
    logic [11:0] addr_offset;
    logic [11:0] max_addr [0:3];
    logic [7:0] ram_out;
    logic [18:0] sample_cnt;
    logic r_sync;
    logic r_prev;
    logic p_sync;
    logic p_prev;
    logic [13:0] base_addr;
    logic sample_tick;
    logic rec_trig;
    logic play_trig;
    always_comb begin
        base_addr = (song_sel * 3000);
        ram_addr = (base_addr + addr_offset);
        if ((sample_cnt == 499999)) begin
            sample_tick = 1'd1;
        end else begin
            sample_tick = 1'd0;
        end
        rec_trig = (r_prev && (!r_sync));
        play_trig = (p_prev && (!p_sync));
        counter_limit = 20'd0;
        unique case (active_keys)
            254: begin
                counter_limit = 20'd95566;
            end
            253: begin
                counter_limit = 20'd85118;
            end
            251: begin
                counter_limit = 20'd75867;
            end
            247: begin
                counter_limit = 20'd71546;
            end
            239: begin
                counter_limit = 20'd63775;
            end
            223: begin
                counter_limit = 20'd56818;
            end
            191: begin
                counter_limit = 20'd50617;
            end
            127: begin
                counter_limit = 20'd47783;
            end
            default: begin
            end
        endcase
        buzzer = buzzer_reg;
    end
    always_ff @(posedge clk) begin
        r_sync <= rec_btn;
        r_prev <= r_sync;
        p_sync <= play_btn;
        p_prev <= p_sync;
        if ((state == REC)) begin
            if (sample_tick) begin
                ram[ram_addr] <= keys;
            end
        end
        ram_out <= ram[ram_addr];
        unique case (state)
            IDLE: begin
                addr_offset <= 12'd0;
                sample_cnt <= 19'd0;
                active_keys <= keys;
                if (rec_trig) begin
                    state <= REC;
                end else if (play_trig) begin
                    state <= PLAY;
                end
            end
            REC: begin
                active_keys <= keys;
                sample_cnt <= (sample_cnt + 1);
                if ((rec_trig || (addr_offset == (3000 - 1)))) begin
                    max_addr[song_sel] <= addr_offset;
                    state <= IDLE;
                end else if (sample_tick) begin
                    sample_cnt <= 19'd0;
                    addr_offset <= (addr_offset + 1);
                end
            end
            PLAY: begin
                active_keys <= ram_out;
                sample_cnt <= (sample_cnt + 1);
                if ((play_trig || (addr_offset == max_addr[song_sel]))) begin
                    state <= IDLE;
                end else if (sample_tick) begin
                    sample_cnt <= 19'd0;
                    addr_offset <= (addr_offset + 1);
                end
            end
            default: begin
            end
        endcase
        if ((counter_limit == 0)) begin
            counter <= 20'd0;
            buzzer_reg <= 1'd0;
        end else if ((counter >= counter_limit)) begin
            counter <= 20'd0;
            buzzer_reg <= (!buzzer_reg);
        end else begin
            counter <= (counter + 1);
        end
    end
endmodule