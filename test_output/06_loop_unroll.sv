// Generated by PyHDL Transpiler
// Source: C:\Users\tkyke\OneDrive\Desktop\pyhdl\test_code\06_loop_unroll.phd

module BitReverse (
    input logic [7:0] data_in,
    output logic [7:0] data_out
);
    always_comb begin
        data_out[0] = data_in[7];
        data_out[1] = data_in[6];
        data_out[2] = data_in[5];
        data_out[3] = data_in[4];
        data_out[4] = data_in[3];
        data_out[5] = data_in[2];
        data_out[6] = data_in[1];
        data_out[7] = data_in[0];
    end
endmodule

module ParityGenerator (
    input logic [7:0] data,
    output logic parity
);
    logic temp;
    always_comb begin
        temp = 1'd0;
        temp = (temp ^ data[0]);
        temp = (temp ^ data[1]);
        temp = (temp ^ data[2]);
        temp = (temp ^ data[3]);
        temp = (temp ^ data[4]);
        temp = (temp ^ data[5]);
        temp = (temp ^ data[6]);
        temp = (temp ^ data[7]);
        parity = temp;
    end
endmodule

module LoopWithStep (
    input logic [7:0] data,
    output logic [3:0] even_bits,
    output logic [3:0] odd_bits
);
    always_comb begin
        even_bits[0] = data[0];
        even_bits[1] = data[2];
        even_bits[2] = data[4];
        even_bits[3] = data[6];
        odd_bits[0] = data[1];
        odd_bits[1] = data[3];
        odd_bits[2] = data[5];
        odd_bits[3] = data[7];
    end
endmodule

module PriorityEncoderLoop (
    input logic [7:0] req,
    output logic [2:0] code,
    output logic valid
);
    always_comb begin
        code = 3'd0;
        valid = 1'd0;
        if (req[0]) begin
            code = 0;
            valid = 1'd1;
        end
        if (req[1]) begin
            code = 1;
            valid = 1'd1;
        end
        if (req[2]) begin
            code = 2;
            valid = 1'd1;
        end
        if (req[3]) begin
            code = 3;
            valid = 1'd1;
        end
        if (req[4]) begin
            code = 4;
            valid = 1'd1;
        end
        if (req[5]) begin
            code = 5;
            valid = 1'd1;
        end
        if (req[6]) begin
            code = 6;
            valid = 1'd1;
        end
        if (req[7]) begin
            code = 7;
            valid = 1'd1;
        end
    end
endmodule

module ArrayInit (
    input logic clk,
    input logic rst,
    output logic ready
);
    logic [7:0] mem [0:7];
    always_ff @(posedge clk or posedge rst) begin
        if (rst) begin
            ready <= 1'd0;
            mem[0] <= 1'd0;
            mem[1] <= 1'd0;
            mem[2] <= 1'd0;
            mem[3] <= 1'd0;
            mem[4] <= 1'd0;
            mem[5] <= 1'd0;
            mem[6] <= 1'd0;
            mem[7] <= 1'd0;
        end else begin
            ready <= 1'd1;
        end
    end
endmodule