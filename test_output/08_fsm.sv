// Generated by PyHDL Transpiler
// Source: C:\Users\tkyke\OneDrive\Desktop\pyhdl\test_code\08_fsm.phd

module SimpleFSM (
    input logic clk,
    input logic rst_n,
    input logic start,
    input logic done,
    output logic busy,
    output logic complete
);
    typedef enum logic [1:0] {IDLE=2'd0, RUN=2'd1, FINISH=2'd2} State_t;
    State_t state;
    always_ff @(posedge clk or negedge rst_n) begin
        if ((!rst_n)) begin
            state <= IDLE;
            busy <= 1'd0;
            complete <= 1'd0;
        end else begin
            busy <= 1'd0;
            complete <= 1'd0;
            unique case (state)
                IDLE: begin
                    if (start) begin
                        state <= RUN;
                        busy <= 1'd1;
                    end
                end
                RUN: begin
                    busy <= 1'd1;
                    if (done) begin
                        state <= FINISH;
                    end
                end
                FINISH: begin
                    complete <= 1'd1;
                    state <= IDLE;
                end
                default: begin
                end
            endcase
        end
    end
endmodule

module TrafficLightFSM (
    input logic clk,
    input logic rst_n,
    input logic timer_done,
    output logic red,
    output logic yellow,
    output logic green
);
    typedef enum logic [1:0] {RED=2'd0, GREEN=2'd1, YELLOW=2'd2} Light_t;
    Light_t curr_light;
    always_comb begin
        red = 1'd0;
        yellow = 1'd0;
        green = 1'd0;
        unique case (curr_light)
            RED: begin
                red = 1'd1;
            end
            GREEN: begin
                green = 1'd1;
            end
            YELLOW: begin
                yellow = 1'd1;
            end
            default: begin
            end
        endcase
    end
    always_ff @(posedge clk or negedge rst_n) begin
        if ((!rst_n)) begin
            curr_light <= RED;
        end else begin
            unique case (curr_light)
                RED: begin
                    if (timer_done) begin
                        curr_light <= GREEN;
                    end
                end
                GREEN: begin
                    if (timer_done) begin
                        curr_light <= YELLOW;
                    end
                end
                YELLOW: begin
                    if (timer_done) begin
                        curr_light <= RED;
                    end
                end
                default: begin
                end
            endcase
        end
    end
endmodule

module UARTReceiverFSM (
    input logic clk,
    input logic rst_n,
    input logic rx,
    input logic bit_done,
    output logic [7:0] data_out,
    output logic data_valid
);
    typedef enum logic [1:0] {IDLE=2'd0, START=2'd1, DATA=2'd2, STOP=2'd3} RxState_t;
    RxState_t state;
    logic [3:0] bit_cnt;
    logic [7:0] shift_reg;
    always_ff @(posedge clk or negedge rst_n) begin
        if ((!rst_n)) begin
            state <= IDLE;
            bit_cnt <= 4'd0;
            shift_reg <= 8'd0;
            data_out <= 8'd0;
            data_valid <= 1'd0;
        end else begin
            data_valid <= 1'd0;
            unique case (state)
                IDLE: begin
                    if ((!rx)) begin
                        state <= START;
                    end
                end
                START: begin
                    if (bit_done) begin
                        state <= DATA;
                        bit_cnt <= 4'd0;
                    end
                end
                DATA: begin
                    if (bit_done) begin
                        shift_reg <= {rx, shift_reg[7:1]};
                        bit_cnt <= (bit_cnt + 1);
                        if ((bit_cnt == 7)) begin
                            state <= STOP;
                        end
                    end
                end
                STOP: begin
                    if (bit_done) begin
                        if (rx) begin
                            data_out <= shift_reg;
                            data_valid <= 1'd1;
                        end
                        state <= IDLE;
                    end
                end
                default: begin
                end
            endcase
        end
    end
endmodule